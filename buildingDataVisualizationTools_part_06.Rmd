---
title: "Building Data Visualization Tools (Part 6)"
author: "Pier Lorenzo Paracchini, `r format(Sys.time(), '%d.%m.%Y')`"
output: 
  html_document: 
    fig_width: 6
    keep_md: yes
    toc: yes
    toc_depth: 5
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, collapse = TRUE)
```

---

The content of this blog is based on examples/ notes/ experiments related to the material presented in the "Building Data Visualization Tools" module of the "[Mastering Software Development in R](https://www.coursera.org/specializations/r)" Specialization (Coursera) created by __Johns Hopkins University__ [1].

Required packages:

- the `ggplot2` package,
- ...

```{r loadRequiredPackages}
# If ggplot2 package is not installed
# install.packages("ggplot2")
library(ggplot2)
```

# Building new graphical elements

Key elements in `ggplot2` are _geoms_ and _stats_, which allow to create interesting and rich data graphics and visualizations.

Why do new graphic capabilities need to be created?

- There is limited support in `ggplot2` for the type opf graphic capabilities needed (new feature).

- The same plot needs to be created over and over and, the creation of the plot is quite complex (simplify a complex workflow).

Building new _geoms_ or _stats_ is the plotting equivalent of writing functions.


The building of a new __geom__/ __stat__ feature follows a two step process:

1. use the `ggplot2::ggproto()` function to create a new class corresponding to your new feature,
    - inheriting from the `Geom` or `Stat` class  
    
2. implement the `geom_*` or `stat_*` function returning a layer that can be added to a plot created using the `ggplot()` function.

All `ggplot2` objects are created using the __ggproto Object-Oriented system__ which allows the creation of mutable objects (for more info about ggproto see http://ggplot2.tidyverse.org/articles/extending-ggplot2.html).

```{r simpleExampleWith_ggproto}

A <- ggplot2::ggproto("_class" = "MyClass", "_inherit" = NULL,
                       x = 1,
                       inc = function(self){
                           self$x <- self$x + 1
                       })

# Check the structure of the object
str(A)

# Visualize the value of x
A$x

# Increment & visualize x
A$inc()
A$x
```

## How to create a new stat

All of the `stat_*` functions return a layer that contains a `Stat*` object. This object is responsible for rendering the data in the plot. Each `Stat*` object is a `ggproto` object and a `Stat` object, implementing some methods/ fields (see `?Stat` for more information).



```{r buldingStatSimpleExample}
# creation of a convex hull

# stat implementation
# (override) compute_group, called once per group
# (override) required_aes, aesthetics needed to render the geom

StatConvexHull <- ggproto("_class" = "StatConvexHull", "_inherit" = Stat, 
                          compute_group = function(data, scales){
                              data[chull(data$x, data$y),, drop = FALSE]
                          },
                          required_aes = c("x", "y"))

# Implement the relevant stat_* function
# The function creates a new layer using the layer function

stat_convexHull <- function(geom = "polygon", data = NULL, mapping = NULL, 
                            position = "identity", na.rm = F, inherit.aes = TRUE, show.legend = NA,
                            ...){
    
    layer(geom = geom, stat = StatConvexHull, 
          data = data, mapping = mapping, position = position, 
          inherit.aes = inherit.aes, show.legend = show.legend,
          params = list(na.rm = na.rm, ...))
}

ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
    geom_point() +
    stat_convexHull(fill = NA, colour = "black")

ggplot(data = mpg, mapping = aes(x = displ, y = hwy, colour = drv)) + 
    geom_point() +
    stat_convexHull(fill = NA)

ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
    geom_point() +
    stat_convexHull(geom = "point", size = 4, colour = "red")

ggplot(data = mpg, mapping = aes(x = displ, y = hwy, colour = drv)) + 
    geom_point() +
    stat_convexHull(geom = "point", size = 4)

```


```{r buildStatMoreComplexExample}
# creation of a simple version of geom_smooth

StatLm <- ggproto("_class" = "StatLm", "_inherit" = Stat,
                  
                  compute_group = function(data, scales, n = 100, formula = y ~x){
                      rng <- range(data$x, na.rm = T)
                      grid <- data.frame(x = seq(rng[1], rng[2], length = n))
                      
                      mod <- lm(formula, data = data)
                      grid$y <- predict(object = mod, newdata = grid)
                      grid
                  },
                  
                  required_aes = c("x", "y")
                  )

stat_lm <- function(mapping = NULL, data = NULL, geom = "line",
                    position = "identity", na.rm = F, show.legend = NA,
                    inherit.aes = T, n = 50, formula = y ~ x, ...){
    
    layer(stat = StatLm, data = data, mapping = mapping, geom = geom, position = position, 
          show.legend = show.legend, inherit.aes = inherit.aes, 
          params = list(n = n, formula = formula, na.rm = na.rm, ...))
    
}

ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
    geom_point() +
    stat_lm()

ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
    geom_point() +
    stat_lm(formula = y ~ poly(x, 6), colour = "red")  +
    stat_lm(formula = y ~ poly(x, 6), geom = "point", n = 10, colour = "red")


```

Sometimes there are calculations that need to be performed once for the dataset, not for each group.

__TO_DO__ find out more information????

```{r buildStatMoreComplexExample_1}

StatDensityCommon <- ggproto("_class" = "StatDensityCommon", "_inherit" = Stat,
                             required_aes = "x",
                             setup_params = function(data, params){
                                 print("Running set_up....")
                                 if(!is.null(params$bandwidth)) return(params)
                                 
                                 xs <- split(data$x, data$group)
                                 bws <- vapply(xs, bw.nrd0, numeric(1))
                                 bw <- mean(bws)
                                 message("Picking bandwidth of ", signif(bw, 3))
                                 
                                 params$bandwidth <- bw
                                 print("End set_up....")
                                 params
                                 
                             },
                             
                             compute_group = function(data, scales, bandwidth = 1){
                                 print(paste("Running compute_group [", unique(data$group), "] ..."))
                                 str(data)
                                 print(bandwidth)
                                 d <- density(data$x,bandwidth)
                                 print("End compute_group....")
                                 data.frame(x = d$x, y = d$y)
                             })

stat_densityCommon <- function(data = NULL, mapping = NULL, geom = "line",
                               position = "identity", na.rm = FALSE, show.legend = NA,
                               inherit.aes = T, bandwidth = NULL, ...){
    layer(geom = geom,  stat = StatDensityCommon, data = data, mapping = mapping, position = position,
          params = list(bandwidth = bandwidth, na.rm = na.rm, ...), inherit.aes = inherit.aes, show.legend = show.legend)
}

ggplot(data = mpg, mapping = aes(x = displ)) +
    stat_densityCommon(bandwidth = 0.25)

# Bandwidth is calculated from the data (once) 
ggplot(data = mpg, mapping = aes(x = displ)) +
    stat_densityCommon()


ggplot(data = mpg, mapping = aes(x = displ, colour = drv)) +
    stat_densityCommon()

```

Important aspects to consider: __variable names__ and __default aesthetics__. If you want to make a _stat_ usable with other _geoms_ we need to be careful with the chosen names.

> If we want to make this stat usable with other geoms, we should return a variable called density instead of y. Then we can set up the default_aes to automatically map density to y, which allows the user to override it to use with different geoms.

```{r buildStatMoreComplexExample_2}
StatDensityCommon <- ggproto("StatDensityCommonE", Stat, 
  required_aes = "x",
  default_aes = aes(y = ..density..),

  compute_group = function(data, scales, bandwidth = 1) {
    print(paste("Running compute_group [", unique(data$group), "] ..."))
    d <- density(data$x, bw = bandwidth)
    print(range(d$x))
    print(range(d$y))
    print("End compute_group....")
    data.frame(x = d$x, density = d$y)
  }  
)

ggplot(mpg, aes(displ, drv, colour = ..density..)) + 
  stat_densityCommon(bandwidth = 1, geom = "point")

# Using this stat with the area geom doesn’t work quite right. 
# The areas don’t stack on top of each other because each density 
# is computed independently, and the estimated xs don’t line up.
ggplot(mpg, aes(displ, fill = drv)) + 
  stat_densityCommon(bandwidth = 1, geom = "area", position = "stack")
```

```{r buildStatMoreComplexExample_3}
StatDensityCommon <- ggproto("StatDensityCommonF", Stat, 
  required_aes = "x",
  default_aes = aes(y = ..density..),
  
  setup_params = function(data, params){
      print("Running set_up....")
      min <- min(data$x) - 3 * params$bandwidth
      max <- max(data$x) + 3 * params$bandwidth
      print(paste("min:", min, "- max:", max, "- bw:", params$bandwidth))
      print("End set_up....")
      list(
        bandwidth = params$bandwidth,
        min = min,
        max = max,
        na.rm = params$na.rm
      )
  },
  
  compute_group = function(data, scales, min, max, bandwidth = 1) {
    print(paste("Running compute_group [", unique(data$group), "] ..."))
    d <- density(data$x, bw = bandwidth, from = min, to = max)
    print(range(d$x))
    print(range(d$y))
    print("End compute_group....")
    data.frame(x = d$x, density = d$y)
  }  
)

ggplot(mpg, aes(displ, fill = drv)) + 
  stat_densityCommon(bandwidth = 0.75, geom = "area", position = "stack")

ggplot(mpg, aes(displ, drv, colour = ..density..)) + 
  stat_densityCommon(bandwidth = 1, geom = "point")

ggplot(mpg, aes(displ, drv, fill = ..density..)) + 
  stat_densityCommon(bandwidth = 1, geom = "raster")
```



# Session Info

```{r information}
sessionInfo()
```


# References

[1] "The grid package" chapter in "[Mastering Software Development in R](http://rdpeng.github.io/RProgDA/the-grid-package.html)" by Roger D. Peng, Sean Cross and Brooke Anderson, 2017  
[2] Vignette ["Introduction to grid"](https://stat.ethz.ch/R-manual/R-devel/library/grid/doc/grid.pdf) by Paul Murrell, April 2017   
[3] Vignette ["Working with grid viewports"](https://stat.ethz.ch/R-manual/R-devel/library/grid/doc/viewports.pdf) by Paul Murrell, November 2016   
[4] Vignette ["Arranging multiple grobs on a page"](https://cran.r-project.org/web/packages/gridExtra/vignettes/arrangeGrob.html) by Baptiste Auguie, September 2017  
[5] Vignette ["(Unofficial) overview of gtable"](https://cran.r-project.org/web/packages/gridExtra/vignettes/gtable.html) by Baptiste Auguie, September 2017  
[6] Vignette ["Displaying tables as grid graphics"](https://cran.r-project.org/web/packages/gridExtra/vignettes/tableGrob.html) by Baptiste Auguie, September 2017  

__Interesting book__:

- "R Graphics" 2nd Edition, by Paul Murrell, September 2015

__Previous "Building Data Visualization Tools" blogs__: 

- Part 1: "[Basic plotting with R and ggplot2](https://pparacch.github.io/2017/07/06/plotting_in_R_ggplot2_part_1.html)"  
- Part 2: "['ggplot2', essential concepts](https://pparacch.github.io/2017/07/14/plotting_in_R_ggplot2_part_2.html)"  
- Part 3: "[Guidelines for good plots](https://pparacch.github.io/2017/07/18/plotting_in_R_ggplot2_part_3.html)"  
- Part 4: "[How to work with maps](https://pparacch.github.io/2017/08/28/plotting_in_R_ggplot2_part_4.html)"  
